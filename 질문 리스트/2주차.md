## Q1. 자바의 상속과 자바스크립트의 프로토타입의 작동 방식에서의 차이
### 자바의 상속
- 클래스 기반 (Class-Based): 자바에서는 클래스를 사용하여 상속을 구현한다. 클래스는 객체를 생성하기 위한 템플릿이며, 객체는 클래스의 인스턴스이다.
- 단일 상속: 자바는 단일 상속만을 지원한다. 즉, 하나의 클래스는 하나의 다른 클래스에서만 상속받을 수 있다.
- 상속의 제어: extends 키워드를 사용하여 어떤 클래스를 상속받을지 지정한다.
- 메소드 오버라이딩: 하위 클래스는 상위 클래스에서 정의된 메소드를 재정의할 수 있다.
- 인터페이스 구현: 다중 상속을 대신하여 인터페이스를 통해 다른 클래스의 기능을 구현할 수 있다.

### 자바스크립트의 프로토타입
- 프로토타입 기반 (Prototype-Based): 자바스크립트에서는 객체 간의 상속을 프로토타입 체인을 통해 구현한다. 각 객체는 다른 객체를 기반으로 생성된다.
- 다중 상속 및 동적 속성: 자바스크립트는 다중 상속을 지원하지 않는다. 객체는 동적으로 속성을 추가하거나 수정할 수 있다.
- prototype 속성: 모든 함수 객체는 prototype이라는 속성을 가지고 있다. 이 prototype 속성은 해당 함수로 생성된 객체의 부모 역할을 한다.
- __proto__ 속성: 모든 객체는 __proto__라는 내부 속성을 가지고 있다. 이 속성은 해당 객체의 부모 객체를 가리킨다.
- 상속의 구현: 객체가 어떤 다른 객체를 상속받을지는 해당 객체의 __proto__ 속성을 설정함으로써 결정된다.
- 프로토타입 체인: 객체가 특정 속성 또는 메소드를 찾을 때, 자바스크립트는 해당 객체의 프로토타입 체인을 따라 부모 객체들을 검색한다.

## Q2. 정적 메소드, 프로토타입 메소드, 인스턴스 메소드를 사용하는 기준은?
- 정적 메소드 : this를 사용하지 않는 메소드는 정적 메소드로 정의해서 사용한다.

#### 생성자 함수 기반
```js
function Person(name) {
  this.name = name;
}

// 정적 메소드
Person.sayHi = function () {
  console.log("HI!");
}

Person.sayHi();
```
#### 클래스 기반
```js
class Person {
  constructor(name) {
    this.name = name;
  }

  // 정적 메소드
  static sayHi() {
    console.log("HI!");
  }
}
```
- 프로토타입 메소드 : 인스턴스의 프로퍼티를 참조해야 할 경우 프로토타입 메소드로 정의해서 사용한다.

#### 생성자 함수 기반
```js
function Person(name) {
  this.name = name;
}

// 프로토타입 메소드
Person.prototype.sayHi = function () {
  console.log(`My Name is ${this.name}`);
}

const me = new Person('Lee');
me.sayHi();
```
#### 클래스 기반
```js
class Person {
  constructor(name) {
    this.name = name;
  }

  // 프로토타입 메소드
  sayHi() {
    console.log(`My Name is ${this.name}`);
  }
}

const me = new Person('Lee');
me.sayHi();
```
- 인스턴스 메소드
> 생성자 함수 기반, 클래스 기반 모두 프로토타입 메소드와 형태가 동일하다. 따로 관련 용어에 대한 설명이 없는 것으로 보아 프로토타입 메소드의 역할과 동일하다고 생각하면 될 것 같다.
## Q3. constructor 프로퍼티의 존재 이유는? 
먼저, `constructor` 프로퍼티는 객체가 어떤 생성자 함수에 의해 생성되었는지를 가리키는 참조이다.
주요 목적은 아래와 같다.
1. 객체의 생성자 식별
2. 상속 및 프로토타입 체이닝
## Q4. [[Prototype]], prototype 프로퍼티, __proto__의 차이
1. `[[Prototype]]`
  - 객체의 부모 역할을 하며, 다른 객체를 가리킨다.
  - 직접 접근이 불가능하고, `__proto__`나 `Object.getPrototypeOf()`를 사용하여 간접적으로 접근할 수 있다.
2. `prototype` 프로퍼티
  - 생성자 함수와 관련이 있다.
  - 함수가 생성자로 사용될 때, 해당 함수의 `prototype` 프로퍼티에 새로운 객체가 자동으로 생성된다.

3. `__proto__`
  - 객체가 직접적으로 사용하는 프로토타입을 가리킨다.
  - 주로 객체 자체에서 사용되며, 객체의 프로토타입을 동적으로 변경하는 데 사용될 수 있다.(하지만, `Object.setPrototypeOf()` 또는 `Object.create()`와 같은 메서드를 사용하는 것이 권장됨)

결론적으로, `[[Prototype]]`은 모든 객체가 가지고 있는 내부 프로퍼티로서 상속 관계를 나타내며, `prototype`은 생성자 함수에 의해 생성된 객체들의 `[[Prototype]]`으로 사용된다. `__proto__`는 객체 자체에서 사용되며, 객체의 프로토타입을 동적으로 변경하는 데 사용된다.
