# 1주차 질문 리스트
|발표일|발표자|발표 챕터|
|--|--|--|
|2023.10.4 |김나현|Ch 4, 5, 12, 13|

## 질문 & 답변

### Q1.변수 호이스팅이 일어난다고 하는데 어느 위치로 호이스팅이 되나요?
**👉🏻호이스팅은 변수선언이 스코프의 선두로 끌어 올려진 것처럼 동작<br/>**
+ 전역 변수의 호이스팅은 전역 스코프의 선두로 끌어 올려진 것처럼 동작
+ 지역 변수의 호이스팅은 지역 스코프의 선두로 끌어올려진 것처럼 동작

### Q2. 스코프에 상관없이 호이스팅이 일어나나요?
**👉🏻호이스팅은 항상 일어나지만 범위는 사용하는 키워드에 따라 달라진다<br/>**
+ var<br/>
var 키워드를 사용한 변수 선언과 함수 선언은 현재 실행 컨텍스트 내에서 가장 위로 끌어올려진다(전역 스코프 혹은 가장 가까운 함수 스코프)
+ let, const<br/>
let과 const 키워드를 사용한 변수 선언은 각각의 블록 스코프 내에서만 호이스팅된다


### Q3. 가비지 컬렉터가 어떻게 동작하나요?

### Q4. 개발자 도구에 함수 표현식을 찍었을 때 생각한 대로라면 함수 객체가 출력되어야 하는데 undefined가 나옵니다. 왜 그런가요?

### Q5. 함수 리터럴이 정확히 어떤 형태를 의미하는건가요?
**👉🏻함수리터럴과 함수선언문은 형태적으로는 매우 유사하지만 주요한 차이점은 함수가 변수에 할당되느냐 그렇지 않느냐에 있다.**
<br/>
<br/>
**1. 함수선언문의 형태**
``` javascript
function greet(name) {
    console.log('Hello, ' + name);
}
```
**2. 함수 리터럴의 형태<br/>**
이름을 지정할 수도 있고, 생략할 수도 있다.
``` javascript
var greet = function(name) {
    console.log('Hello, ' + name);
};

// or with a function name

var greet = function greeting(name) {
    console.log('Hello, ' + name);
};
```



### Q6. 즉시실행함수를 왜 사용하나요?
**1. 전역 네임스페이스를 오염시키는 것을 방지<br/>**
애플리케이션은 다양한 소스 파일의 많은 함수와 전역 변수를 포함할 수 있기 때문에, 전역 변수의 수를 제한하는 것이 중요. 필요 없는 초기화 코드가 있는 경우, IIFE 패턴을 사용할 수 있다. 코드를 다시 재사용하지 않을 것이기 때문에 이 경우 IIFE를 사용하는 것이 함수 선언 또는 함수 표현식을 사용하는 것보다 더 좋다.
``` javascript
(() => {
  // 초기화 코드
  let firstVariable;
  let secondVariable;
})();

// firstVariable와 secondVariable은 이 함수 실행 후에 사용할 수 없다.
```
**2. 비동기 함수 실행<br/>**
async IIFE를 사용하면 top-level await이 없는 이전 브라우저 및 JavaScript 런타임에서도 await 및 for-await을 사용할 수 있다.
``` javascript
const getFileStream = async (url) => {
  // 구현
};

(async () => {
  const stream = await getFileStream("https://domain.name/path/file.ext");
  for await (const chunk of stream) {
    console.log({ chunk });
  }
})();
```
**3. 모듈 패턴<br/>**
비공개 및 공개 변수와 메서드를 생성할 수 있다
``` javascript
const makeWithdraw = (balance) =>
  ((copyBalance) => {
    let balance = copyBalance; // This variable is private
    const doBadThings = () => {
      console.log("I will do bad things with your money");
    };
    doBadThings();
    return {
      withdraw(amount) {
        if (balance >= amount) {
          balance -= amount;
          return balance;
        }
        return "Insufficient money";
      },
    };
  })(balance);

const firstAccount = makeWithdraw(100); // "I will do bad things with your money"
console.log(firstAccount.balance); // undefined
console.log(firstAccount.withdraw(20)); // 80
console.log(firstAccount.withdraw(30)); // 50
console.log(firstAccount.doBadThings); // undefined; this method is private
const secondAccount = makeWithdraw(20); // "I will do bad things with your money"
console.log(secondAccount.withdraw(30)); // "Insufficient money"
console.log(secondAccount.withdraw(20)); // 0
```




### Q7. 변수 선언이 렉시컬 환경에다가 스코프 체인 형태로 키/값으로 등록하는 것을 의미하는건가요? 
**👉🏻넵<br/>**
렉시컬 환경은 환경 레코드, 외부 렉시컬 환경에 대한 참조 두 개의 컴포넌트로 구성된다.<br/>
환경 레코드에 현재 컨텍스트 내에서 선언된 모든 식별자를 키/값 쌍으로 저장한다.


### Q8. 함수 호이스팅을 방지해야 한다고 했는데 왜 방지해야 하나요?
**1. 코드의 순서와 실행 순서가 일치하지 않음<br/>**
코드를 읽는 사람에게 혼란을 일으킬 수 있다
<br/>
**2. 변수와 함수의 이름 충돌<br/>**
만약 변수와 함수가 같은 이름을 가지고 있으면 호이스팅으로 인해 예상치 못한 결과가 발생할 수 있다
``` javascript
foo(); // "This is a function"

function foo() {
    console.log("This is a function");
}

var foo = "I'm a variable";

console.log(foo); // "I'm a variable"
```
**foo라는 이름의 함수와 변수가 동시에 선언됨<br/>**
➡️호이스팅에 의해 함수 선언문과 var 키워드를 사용한 변수 선언문은 스코프의 최상단으로 끌어올려진다.<br/>
➡️그러나, 함수 선언문은 이름과 함께 전체 함수를 끌어올리지만, 변수 선언문은 오직 이름만을 끌어올린다.<br/>
➡️따라서 첫 번째 foo() 호출에서는 해당 이름의 함수가 호출되고 "This is a function"이 출력된다.<br/>
➡️그런데 이후에 var foo = "I'm a variable"; 코드가 실행되면서 동일한 이름을 가진 foo 변수가 새로운 값으로 초기화된다.<br/>
➡️이로 인해 기존의 foo 함수는 덮어씌워지게 된다.<br/>
➡️결국 마지막 줄인 console.log(foo);에서 출력되는 값은 문자열 "I'm a variable"이다.<br/>
👉🏻만약 다른 부분에서 foo 함수를 호출하려 했다면 에러(TypeError: foo is not a function)가 발생할 것


### Q9. 콜백함수를 이용해 싱글스레드 언어의 특성을 보완할 수 있다?



### Q10. (궁금) 함수는 식별자로 호출하는데 그렇다면 함수 이름의 존재 이유는 뭘까?
**1. 디버깅<br/>**
 함수에 이름을 부여하면, 개발자 도구의 스택 추적에서 해당 함수를 식별하기 쉽다<br/>
 예를 들어 다음과 같은 코드가 있다고 가정했을 때
 ``` javascript
function firstFunction() {
    secondFunction();
}

function secondFunction() {
    thirdFunction();
}

var thirdFunction = function() {
    throw new Error('An error occurred');
};

firstFunction();
```
익명함수에서 에러가 발생하면 개발자 도구의 콘솔에 출력되는 스택 추적은 다음과 같다
``` javascript
Error: An error occurred
    at secondFunction (<anonymous>:9:11)
    at firstFunction (<anonymous>:4:5)
    at <anonymous>:14:1
```
여기서 thirdFunction은 <anonymous>로 표시되지만, 만약 함수 이름을 부여한다면 문제가 발생한 위치를 알 수 있기 떄문에 디버깅을 쉽게 해준다 

**2. 재귀호출<br/>**
재귀 호출의 경우, 함수 이름을 사용하여 자기 자신을 참조
``` javascript
var factorial = function fact(n) {
    if (n < 2) {
        return 1;
    }
    return n * fact(n - 1);
};
```
