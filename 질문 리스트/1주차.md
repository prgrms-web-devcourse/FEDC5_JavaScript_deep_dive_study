# 1주차 질문 리스트
|발표일|발표자|발표 챕터|
|--|--|--|
|2023.10.4 |김나현|Ch 4, 5, 12, 13|

## 질문 & 답변

### Q1.변수 호이스팅이 일어난다고 하는데 어느 위치로 호이스팅이 되나요?
**👉🏻호이스팅은 변수선언이 스코프의 선두로 끌어 올려진 것처럼 동작<br/>**
+ 전역 변수의 호이스팅은 전역 스코프의 선두로 끌어 올려진 것처럼 동작
+ 지역 변수의 호이스팅은 지역 스코프의 선두로 끌어올려진 것처럼 동작

### Q2. 스코프에 상관없이 호이스팅이 일어나나요?


### Q3. 가비지 컬렉터가 어떻게 동작하나요?

### Q4. 개발자 도구에 함수 표현식을 찍었을 때 생각한 대로라면 함수 객체가 출력되어야 하는데 undefined가 나옵니다. 왜 그런가요?

### Q5. 함수 리터럴이 정확히 어떤 형태를 의미하는건가요?
**👉🏻함수리터럴과 함수선언문은 형태적으로는 매우 유사하지만 주요한 차이점은 함수가 변수에 할당되느냐 그렇지 않느냐에 있다.**
<br/>
<br/>
**1. 함수선언문의 형태**
``` javascript
function greet(name) {
    console.log('Hello, ' + name);
}
```
**2. 함수 리터럴의 형태<br/>**
이름을 지정할 수도 있고, 생략할 수도 있다.
``` javascript
var greet = function(name) {
    console.log('Hello, ' + name);
};

// or with a function name

var greet = function greeting(name) {
    console.log('Hello, ' + name);
};
```



### Q6. 즉시실행함수를 왜 사용하나요?
**1. 전역 네임스페이스를 오염시키는 것을 방지<br/>**
애플리케이션은 다양한 소스 파일의 많은 함수와 전역 변수를 포함할 수 있기 때문에, 전역 변수의 수를 제한하는 것이 중요. 필요 없는 초기화 코드가 있는 경우, IIFE 패턴을 사용할 수 있다. 코드를 다시 재사용하지 않을 것이기 때문에 이 경우 IIFE를 사용하는 것이 함수 선언 또는 함수 표현식을 사용하는 것보다 더 좋다.
``` javascript
(() => {
  // 초기화 코드
  let firstVariable;
  let secondVariable;
})();

// firstVariable와 secondVariable은 이 함수 실행 후에 사용할 수 없다.
```
**2. 비동기 함수 실행<br/>**
async IIFE를 사용하면 top-level await이 없는 이전 브라우저 및 JavaScript 런타임에서도 await 및 for-await을 사용할 수 있다.
``` javascript
const getFileStream = async (url) => {
  // 구현
};

(async () => {
  const stream = await getFileStream("https://domain.name/path/file.ext");
  for await (const chunk of stream) {
    console.log({ chunk });
  }
})();
```
**3. 모듈 패턴<br/>**
비공개 및 공개 변수와 메서드를 생성할 수 있다
``` javascript
const makeWithdraw = (balance) =>
  ((copyBalance) => {
    let balance = copyBalance; // This variable is private
    const doBadThings = () => {
      console.log("I will do bad things with your money");
    };
    doBadThings();
    return {
      withdraw(amount) {
        if (balance >= amount) {
          balance -= amount;
          return balance;
        }
        return "Insufficient money";
      },
    };
  })(balance);

const firstAccount = makeWithdraw(100); // "I will do bad things with your money"
console.log(firstAccount.balance); // undefined
console.log(firstAccount.withdraw(20)); // 80
console.log(firstAccount.withdraw(30)); // 50
console.log(firstAccount.doBadThings); // undefined; this method is private
const secondAccount = makeWithdraw(20); // "I will do bad things with your money"
console.log(secondAccount.withdraw(30)); // "Insufficient money"
console.log(secondAccount.withdraw(20)); // 0
```




### Q7. 변수 선언이 렉시컬 환경에다가 스코프 체인 형태로 키/값으로 등록하는 것을 의미하는건가요? 
**👉🏻넵<br/>**
렉시컬 환경은 환경 레코드, 외부 렉시컬 환경에 대한 참조 두 개의 컴포넌트로 구성된다.<br/>
환경 레코드에 현재 컨텍스트 내에서 선언된 모든 식별자를 키/값 쌍으로 저장한다.


### Q8. 함수 호이스팅을 방지해야 한다고 했는데 왜 방지해야 하나요?



### Q9. 콜백함수를 이용해 싱글스레드 언어의 특성을 보완할 수 있다?



### Q10. (궁금) 함수는 식별자로 호출하는데 그렇다면 함수 이름의 존재 이유는 뭘까?
**1. 디버깅<br/>**
 함수에 이름을 부여하면, 개발자 도구의 스택 추적에서 해당 함수를 식별하기 쉽다<br/>
 예를 들어 다음과 같은 코드가 있다고 가정했을 때
 ``` javascript
function firstFunction() {
    secondFunction();
}

function secondFunction() {
    thirdFunction();
}

var thirdFunction = function() {
    throw new Error('An error occurred');
};

firstFunction();
```
익명함수에서 에러가 발생하면 개발자 도구의 콘솔에 출력되는 스택 추적은 다음과 같다
``` javascript
Error: An error occurred
    at secondFunction (<anonymous>:9:11)
    at firstFunction (<anonymous>:4:5)
    at <anonymous>:14:1
```
여기서 thirdFunction은 <anonymous>로 표시되지만, 만약 함수 이름을 부여한다면 문제가 발생한 위치를 알 수 있기 떄문에 디버깅을 쉽게 해준다 

**2. 재귀호출<br/>**
재귀 호출의 경우, 함수 이름을 사용하여 자기 자신을 참조
``` javascript
var factorial = function fact(n) {
    if (n < 2) {
        return 1;
    }
    return n * fact(n - 1);
};
```
