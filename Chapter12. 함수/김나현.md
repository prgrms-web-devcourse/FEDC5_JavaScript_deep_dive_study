# Chapter 12: 함수

## 12.1 함수란?
> 일련의 과정을 코드 블록으로 감싸서 하나의 실행단위로 정의한 것이다


## 12.2 함수를 사용하는 이유
+ **코드의 재사용**을 가능하게 한다
+ **유지보수의 편의성**을 높인다
+ 실수를 줄여**코드의 신뢰성** 을 높인다
+ 함수의 식별자로 **코드의 가독성**이 향상된다



## 12.3 함수 리터럴
+ 자바스크립트에서 **함수는 객체**다
+ 따라서 객체를 객체 리터럴로 생성하는 것처럼 함수도 **함수 리터럴**로 생성할 수 있다
+ 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다
``` javascript
// 변수에 함수 리터럴을 할당
const f = function add(x, y) {
	return x + y;
};

// 식별자로 호출
console.log(f(1, 2));
```
+ function add(x, y){ return x + y; }는 함수 리터럴이다<br/>
▶️이 함수 리터럴은 메모리에 저장되며 그 위치를 참조하는 참조값이 생성된다<br/>
▶️그 후 var f = ... 부분에서 변수 f가 이 참조값을 할당받는다 <br/>
▶️따라서 f는 이제 해당 함수를 가리키게 된다





## 12.4 함수 정의

### 함수 선언문
+ 함수 리터럴과 형태가 동일하다
  - 함수리터럴은 함수이름을 생략할 수 있지만, 함수 선언문은 이름을 생략할 수 없다
``` javascript
// 함수 선언문
function add(x, y) {
	return x + y;
}
```
+ 함수 선언문은 `표현식이 아닌 문`이다. 표현식이 아닌 문은 결 값을 반환하지 않는 문이며, 이러한 문은 주로 어떤 동작을 수행하기 위해 사용된
다.


### 함수 표현식
+ 함수는 값의 성질을 갖는 `일급객체`이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있고, 프로퍼티 값이 될 수도 있고, 배열의 요소가 될 수도 있다
+ 일반적로 함수 표현식의 함수리터럴은 이름을 생략한다
``` javascript
// 함수 표현식
var add = function plus(x, y){
	return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

// 함수 이름은 함수 몸체 내부에서만 유효하기 때문에 다음과 같은 코드는 에러가 난다
console.log(plus(2, 5)); // ReferenceError: foo is not defined
```
+ 함수 표현식은 `표현식인 문`이다. 표현식인 문은 값을 반환하는 식으로 구성되어 있고, 이러한 식은 값으로 평가되며, 할당 연산자(=, +=, 등)와 함께 변수에 할당한다.

  


### 함수 생성 시점과 함수 호이스팅
+ **함수 선언문**은 변수가 호이스팅되는 것처럼 `런타임 이전`에 함수객체가 생성돼서 함수 호이스팅된다
+ **함수 표현식**은 변수의 선언과 변수의 할당까지 일어나기 때문에 변수가 할당되는것은 `런타임`에 평가되므로 함수표현식도 할당문이 실행되는 시점에 함수 객체가 생성된다(호이스팅되지 않는다)
``` javascript
console.log(add); // f add(x, y)
console.log(sub); // undefined

function add(a, b) {
  return a + b
};

var sub = function (x, y){
  return x - y;
}
```
+ 따라서 sub의 경우 함수호이스팅이 아닌 `변수 호이스팅`이 일어난 것이다
+ 함수 호이스팅을 방지하기 위해 함수 선언문대신 함수 표현식을 사용하는 것이 권장된다



### Function 생성자 함수
``` javascript
var add = new Function('x', 'y', 'return x+y');

console.log(add(2, 5)); // 7
```
+ Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지 않다


### 화살표 함수
``` javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
+ ES6에서 도입
+ function 키워드 대신 화살표를 사용



## 12.5 함수 호출

### 매개변수와 인수
``` javascript
// 함수 선언문
function add(x, y) {
	return x + y;
}

// 함수 호출
// 인수 1과 2가 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다다
var result = add(1, 2);
```
+ 매개변수를 통해 필요한 값을 함수 외부에서 함수 내부로 전달한다
+ 함수 몸체 내부에서 변수와 동일하게 취급
+ 매개변수의 스코프는 함수내부이다





### 인수확인
+ 자바스크립트는 매개변수와 인수의 개수 일치를 확인하지 않는다
+ 매개변수의 타입을 지정할 수 없다
<br/>

👉🏻적절한 인수가 전달되었는지 확인하거나, 타입스크립트를 도입하는 방법이 있다



### 매개변수의 최대 개수
+ 최대 3개
+ 이상적인 함수는 한가지 일만 하는 것이기 때문에 적을수록 좋다



### 반환문(return 키워드)
+ 반환문은 함수 몸체 내부에서만 사용할 수 있다
+ 함수의 실행을 중단하고 함수를 빠져나간다
``` javascript
function multiply(x, y) {
	return x * y; // 반환문
	console.log('실행되지 않는다');
}
console.log(multiply(3, 5)); // 15
```
+ return 키워드 뒤에 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.


  
## 12.6 참조에 의한 전달과 외부 상태의 변경
+ 매개변수가 원시값일 때
	- `값에 의한 전달`
  - 원시값은 값을 복사해 전달하기 때문에 영향이 없다
+ 매개변수가 객체일 때
	- `참조에 의한 전달`
  - person 객체를 매개변수로 전달하면 함수 내부에서 이를 수정할 경우 원본 객체가 변경되는 부수 효과(side effect)가 발생한다.
``` javascript
// 매개변수 primitive는 원시값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = { name: 'Lee' };

console.log(num); // 100
console.log(person); // {name: "Lee"}

// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.
changeVal(num, person);

// 원시값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // {name: "Kim"}
```
**👉 객체의 상태 변경이 필요하다면 깊은복사deep copy를 통해 새로운 객체를 생성하고 재할당을 통해 교체해야된다**


 
## 12.7 다양한 함수의 형태
+ 즉시실행함수
  - 함수 정의와 동시에 즉시호출되며 다시 호출할 수 없다
  - 일반적으로 익명함수를 사용한다
  - 즉시실행 함수의 내부에 있는 변수는 그 스코프 내에서만 접근이 가능하기 때문에<br/>
  **(1)전역 네임스페이스를 오염시키지 않고 코드를 작성할 수 있다**<br/>
  **(2)다른 사람이 작성한 코드와 충돌없이 자신만의 변수와 함수를 보호 할 수 있다**
  ``` javascript
  (function() {
    var privateVariable = "I'm private";
    console.log(privateVariable);
  })(); // "I'm private"

  console.log(privateVariable); // Uncaught ReferenceError: privateVariable is not defined
  ```
  
+ 재귀 함수
  - 자기 자신을 호출하는 것
  - 탈출조건이 없으면 함수가 무한 호출되어 에러가 발생한다
    
+ 중첩 함수(내부함수)
  - 내부에서만 접근가능하고 외부에서는 직접 호출할 수 없다
  - 중첩함수는 외부함수의 변수를 참조할 수 있다
  - 외부에서 직접 접근할 수 없도록 하여 코드의 안정성을 높이고 잘못된 사용으로 부터 보호할 수 있다
    
+ 콜백 함수
  - 고차함수: 다른 함수를 인자로 받는 함수
  - 콜백함수: 고차함수 내부에서 호출되는 함수
  - 콜백함수를 이용해 한번에 하나의 작업만 할 수 있는 싱글스레드 언어의 특성을 보완할 수 있다. 시간이 오래걸리는 작업을 시작하고나서 바로 다음 코드 실행하기 때문에 멈추지않는다.
  ``` javascript
  console.log(start);

  setTimeout(function(){
    console.log("2초후");
  }, 2000);

  console.log('end');
  ```
  - 배열 메서드 중 map, filter, reduce 등은 모두 고차함수이다. 이 메서드들은 각각의 동작을 위해 적절한 로직이 담긴 콜백함수를 인자로 받아 사용하기 때문이다
  
+ 순수 함수와 비순수 함수
  - 순수함수는 같은 입력에 대해 항상 같은 출력을 반환한다
  ``` javascript
  function add(a, b) {
  return a + b;
  }

  add(1, 2) // 항상 3
  ```
  - 비순수함수 외부 변수의 상태를 변경하기때문에 side effect가 있다
  ``` javascript
  let sum = 0;

  function add(a, b) {
    sum = a + b;
  }

  add(1, 2);
  ```
> side effect를 방지하기 위해서는 외부 상태변경이 가능한 비순수 함수를 최대한 줄이고, 함수 내부 상태에만 의존하는 순수함수를 사용하는 것이 좋다
  
